(define $N 3)
(define $params [| x y z |])
(define $g [| [| 1 0 0 |] [| 0 1 0 |] [| 0 0 1 |] |])

(define $d
  (lambda [%X]
    !((flip ∂/∂) params X)))

(define $hodge
  (lambda [%A]
    (let {[$k (df-order A)]}
      (with-symbols {i j}
        (* (sqrt (abs (M.det g_#_#)))
           (foldl . (. A_[j_1]..._[j_k]
                       (ε' N k)_[i_1]..._[i_N])
                  (map 1#g~[i_%1]~[j_%1] (between 1 k))))))))

(define $dx [| 1 0 0 |])
(define $dy [| 0 1 0 |])
(define $dz [| 0 0 1 |])

(define $ι
  (lambda [%X %Y]
    (* (df-order Y) (. X~i (df-normalize Y_i)))))

(define $Lie
  (lambda [%X %Y]
    (match (df-order Y) integer
      {[,0 (ι X (d Y))]
       [,N (d (ι X Y))]
       [_ (+ (ι X (d Y)) (d (ι X Y)))]})))

(define $ρ (function [t x y z]))
(define $*ρ (df-normalize (hodge ρ)))

(define $ux (function [t x y z]))
(define $uy (function [t x y z]))
(define $uz (function [t x y z]))
(define $u [| ux uy uz |])

(df-normalize (+ (∂/∂ *ρ t) (Lie u *ρ)))
;(tensor {3 3 3} {0 0 0 0 0 (/ (+ ρ|t (* ux|x ρ) (* ux ρ|x) (* uy|y ρ) (* uy ρ|y) (* uz|z ρ) (* uz ρ|z)) 6) 0 (/ (+ (* -1 ρ|t) (* -1 ux|x ρ) (* -1 ux ρ|x) (* -1 uz|z ρ) (* -1 uz ρ|z) (* -1 uy|y ρ) (* -1 uy ρ|y)) 6) 0 0 0 (/ (+ (* -1 ρ|t) (* -1 uy|y ρ) (* -1 uy ρ|y) (* -1 ux|x ρ) (* -1 ux ρ|x) (* -1 uz|z ρ) (* -1 uz ρ|z)) 6) 0 0 0 (/ (+ ρ|t (* uy|y ρ) (* uy ρ|y) (* uz|z ρ) (* uz ρ|z) (* ux|x ρ) (* ux ρ|x)) 6) 0 0 0 (/ (+ ρ|t (* uz|z ρ) (* uz ρ|z) (* ux|x ρ) (* ux ρ|x) (* uy|y ρ) (* uy ρ|y)) 6) 0 (/ (+ (* -1 ρ|t) (* -1 uz|z ρ) (* -1 uz ρ|z) (* -1 uy|y ρ) (* -1 uy ρ|y) (* -1 ux|x ρ) (* -1 ux ρ|x)) 6) 0 0 0 0 0} )

(df-normalize (+ (∂/∂ *ρ t) (Lie u *ρ)))_1_2_3
;(/ (+ ρ|t
;      (* ux|x ρ) (* ux ρ|x)
;      (* uy|y ρ) (* uy ρ|y)
;      (* uz|z ρ) (* uz ρ|z))
;   6)