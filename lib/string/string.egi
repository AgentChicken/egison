;;;;;
;;;;;
;;;;; String
;;;;;
;;;;;

(define $string
  (matcher
    {[,$val []
      {[$tgt  (if (eq? val tgt)
                {[]}
                {})]}]
     [<nil> []
      {[$tgt (if (eq? "" tgt)
               {[]}
               {})]}]
     [<cons $ $> [char string]
      {[$tgt (if (eq? "" tgt)
               {}
               {(unsnoc-string tgt)})]}]
     [<join $ <cons ,$px $>> [string string]
      {[$tgt (match-all (split (pack {px}) tgt) (list string)
               [<join $xs $ys> [(S.append (car xs) (S.concat (map (S.append (pack {px}) $) (cdr xs))))
                                (S.append (car ys) (S.concat (map (S.append (pack {px}) $) (cdr ys))))
                                ]])]}]
     [<join $ <join ,$pxs $>> [string string]
      {[$tgt (match-all (split-string tgt) (list string)
               [<join $xs $ys> [(S.append (car xs) (S.concat (map (S.append px $) (cdr xs))))
                                (S.append (car ys) (S.concat (map (S.append px $) (cdr ys))))
                                ]])]}]
     [$ [something]
      {[$tgt {tgt}]}]
     }))

(define $chop
  (lambda [$xs]
    (match xs string
      {[<snoc (| ,'\n' ,' ') $ys> (chop ys)]
       [_ xs]})))

;;;
;;; String as Collection
;;;

(define $S.length
  (lambda [$xs]
    (length-string xs)))

(define $S.split
  (lambda [$in $ls]
    (split-string in ls)))

(define $S.append
  (lambda [$xs $ys]
    (append-string xs ys)))

(define $S.concat
  (lambda [$xss]
    (foldr (lambda [$xs $rs] (S.append xs rs))
           ""
           xss)))

(define $S.intercalate (compose intersperse S.concat))
