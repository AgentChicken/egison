;;;;;
;;;;;
;;;;; String
;;;;;
;;;;;

(define $string
  (matcher
    {[,$val []
      {[$tgt  (if (eq? val tgt)
                {[]}
                {})]}]
     [<nil> []
      {[$tgt (if (eq? "" tgt)
               {[]}
               {})]}]
     [<cons $ $> [char string]
      {[$tgt (if (eq? "" tgt)
               {}
               {(uncons-string tgt)})]}]
     [<join $ <cons ,$px $>> [string string]
      {[$tgt (match-all (S.split (pack {px}) tgt) (list string)
               [<join (& ^<nil> $xs) (& ^<nil> $ys)> [(S.intercalate (pack {px}) xs)
                                (S.intercalate (pack {px}) ys)
                                ]])]}]
     [<join $ <join ,$pxs $>> [string string]
      {[$tgt (match-all (S.split pxs tgt) (list string)
               [<join (& ^<nil> $xs) (& ^<nil> $ys)> [(S.intercalate pxs xs)
                                (S.intercalate pxs ys)
                                ]])]}]
     [<join $ $> [string string]
      {[$tgt (match-all tgt string
                 [(loop $i [1 $n] <cons $xa_i ...> $rs) [(pack (map (lambda [$i] xa_i) (between 1 n))) rs]])]}]
     [$ [something]
      {[$tgt {tgt}]}]
     }))

(define $chop
  (lambda [$xs]
    (match xs string
      {[<snoc (| ,'\n' ,' ') $ys> (chop ys)]
       [_ xs]})))

;;;
;;; String as Collection
;;;

(define $S.length
  (lambda [$xs]
    (length-string xs)))

(define $S.split
  (lambda [$in $ls]
    (split-string in ls)))

(define $S.append
  (lambda [$xs $ys]
    (append-string xs ys)))

(define $S.concat
  (lambda [$xss]
    (foldr (lambda [$xs $rs] (S.append xs rs))
           ""
           xss)))

(define $S.intercalate (compose intersperse S.concat))
