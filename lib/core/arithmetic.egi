;;;;;
;;;;;
;;;;; Arithmetic Operation
;;;;;
;;;;;

(define $to-math-expr (macro [$arg] (math-normalize (apply to-math-expr' arg))))

(define $+ (macro [$arg] (math-normalize (apply +' arg))))
(define $- (macro [$arg] (math-normalize (apply -' arg))))
(define $* (macro [$arg] (math-normalize (apply *' arg))))
(define $/ (macro [$arg] (math-normalize (apply /' arg))))

(define $sum
  (lambda [$xs]
    (foldl + 0 xs)))

(define $sum'
  (lambda [$xs]
    (foldl +' 0 xs)))

(define $product
  (lambda [$xs]
    (foldl * 1 xs)))

(define $product'
  (lambda [$xs]
    (foldl *' 1 xs)))

(define $power
  (lambda [$x $n]
    (foldl * 1 (take n (repeat1 x)))))

(define $power'
  (lambda [$x $n]
    (foldl *' 1 (take n (repeat1 x)))))

(define $**
  (lambda [$x $n]
    (if (rational? n)
      (if (gte? n 0)
        (if (integer? n)
          (power x n)
          (to-math-expr <Apply "**" (map from-math-expr {x n})>))
        (/ 1 (** x (neg n))))
      (to-math-expr <Apply "**" (map from-math-expr {x n})>))))

(define $**'
  (lambda [$x $n]
    (if (rational? n)
      (if (gte? n 0)
        (if (integer? n)
          (power' x n)
          (to-math-expr' <Apply "**" (map from-math-expr {x n})>))
        (/' 1 (**' x (neg n))))
      (to-math-expr' <Apply "**" (map from-math-expr {x n})>))))

(define $gcd
  (lambda [$x $y]
    (match [x y] [term-expr term-expr]
      {[[<term $a $xs> <term $b $ys>]
        (* (gcd' (abs a) (abs b)) (foldl *' 1 (map 2#(**' %1 %2) (AC.intersect xs ys))))]})))

(define $gcd'
  (lambda [$x $y]
    (match [x y] [integer integer]
      {[[,0 _] y]
       [[_ ,0] x]
       [[_ ?(gte? $ x)] (gcd' (modulo y x) x)]
       [[_ _] (gcd' y x)]})))

(define $rt
  (lambda [$n $x]
    (if (integer? n)
      (match x math-expr
        {[,0 0]
         [?monomial? (rt' n x)]
         [<div <plus $xs> <plus $ys>>
          (let {[$xd (reduce gcd xs)]
                [$yd (reduce gcd ys)]}
            (let {[[$a $r] (from-monomial (rt' n (/ xd yd)))]}
              (*' a
                 (rt'' n (*' (** r 2) (/' (sum' (map (/' $ xd) xs)) (sum' (map (/' $ yd) ys)))))
                 )))]})
      (rt'' n x))))

(define $rt'
  (lambda [$n $x]
    (letrec {[$f (lambda [$xs]
                   (match xs (assoc-multiset integer)
                     {[<nil> [1 1]]
                      [<ncons $k $p $rs>
                       (let {[$ret (f rs)]}
                         [(*' (**' p (quotient k n)) (2#%1 ret)) (*' (**' p (remainder k n)) (2#%2 ret))])]}))]}
      (letrec {[$g (lambda [$x]
                     (match x term-expr
                       {[<term $a $xs>
                         (match (f {@(to-assoc (p-f (abs a))) @xs}) [math-expr math-expr]
                           {[[$x ,1] (if (lt? a 0) (*' i x) x)]
                            [[$y $z] (if (lt? a 0) (*' i y (rt'' n z)) (*' y (rt'' n z)))]})]}))]}
        (/' (g (numerator x)) (g (denominator x)))))))

(define $rt''
  (lambda [$n $x]
    (match [n x] [integer integer]
      {[[,2 _] (to-math-expr' <Apply "sqrt" (map from-math-expr {x})>)]
       [[_ _] (to-math-expr' <Apply "rt" (map from-math-expr {n x})>)]})))

(define $sqrt
  (lambda [$x]
    (if (number? x)
      (let {[$m (numerator x)]
            [$n (denominator x)]}
        (/ (rt 2 (* m n)) n))
      (sqrt' x))))

(define $rt-of-unity rtu)

(define $rtu
  (lambda [$n]
    (rtu' n)))

(define $rtu'
  (lambda [$n]
    (if (integer? n)
      (match n integer
        {[,1 1]
         [,2 -1]
         [,3 w]
         [,4 i]
         [_ (to-math-expr' <Apply "rtu" (map from-math-expr {n})>)]
         })
      (to-math-expr' <Apply "rtu" (map from-math-expr {n})>))))

(define $quadratic-formula q-f)

(define $q-f
  (lambda [$a $b $c]
    {(/ (+ (* -1 b) (sqrt (- (** b 2) (* 4 a c)))) (* 2 a))
     (/ (- (* -1 b) (sqrt (- (** b 2) (* 4 a c)))) (* 2 a))}))


(define $d/d
  (lambda [$f $x]
    (match f math-expr
      {[?simple-term?
        (match [x f] [symbol-expr symbol-expr]
          {[[<symbol $name> <symbol !,name>] 0]
           [[<symbol $name> <symbol ,name>] 1]
           [[_ <apply ,"exp" <cons $y <nil>>>] (* (exp y) (d/d y x))]
           [[_ <apply ,"log" <cons $y <nil>>>] (* (/ 1 y) (d/d y x))]
           [[_ <apply ,"cos" <cons $y <nil>>>] (* (sin y) (d/d y x))]
           [[_ <apply ,"sin" <cons $y <nil>>>] (* -1 (cos y) (d/d y x))]
           [[_ <apply ,"sqrt" <cons $y <nil>>>] (* (/ 1 (* 2 (sqrt y))) (d/d y x))]
           })]
       [?term? 
        (match [x f] [symbol-expr term-expr]
          {[[_ <term _ <nil>>]
            0]
           [[_ <term ,1 <ncons $n $s <nil>>>]
            (* n (** s (- n 1)) (d/d s x))]
           [[_ <term $a <cons $fx $ts>>]
            (+ (* (d/d fx x)
                  a (foldl *' 1 (map 2#(**' %1 %2) ts)))
               (* fx
                  (d/d (*  a (foldl *' 1 (map 2#(**' %1 %2) ts))) x)))]
           })]
       [?polynomial?
        (match [x f] [symbol-expr poly-expr]
          {[[_ <plus $ts>]
            (sum (map (d/d $ x) ts))]
           })]
       [_ 
        (match [x f] [symbol-expr math-expr]
          {[[_ <div $p1 $p2>]
            (let {[$p1' (d/d p1 x)]
                  [$p2' (d/d p2 x)]}
              (/ (- (* p1' p2) (* p2' p1)) (** p2 2)))]
           })]
       })))
