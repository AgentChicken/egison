;;;;;
;;;;;
;;;;; Arithmetic Operation
;;;;;
;;;;;


(define $to-math-expr (macro [$arg] (math-normalize (apply to-math-expr' arg))))

(define $+ (macro [$arg] (math-normalize (apply +' arg))))
(define $- (macro [$arg] (math-normalize (apply -' arg))))
(define $* (macro [$arg] (math-normalize (apply *' arg))))
(define $/ (macro [$arg] (math-normalize (apply /' arg))))

(define $sum
  (lambda [$xs]
    (foldl + 0 xs)))

(define $sum'
  (lambda [$xs]
    (foldl +' 0 xs)))

(define $product
  (lambda [$xs]
    (foldl * 1 xs)))

(define $product'
  (lambda [$xs]
    (foldl *' 1 xs)))

(define $power
  (lambda [$x $n]
    (foldl * 1 (take n (repeat1 x)))))

(define $power'
  (lambda [$x $n]
    (foldl *' 1 (take n (repeat1 x)))))

(define $**
  (lambda [$x $n]
    (if (rational? n)
      (if (gte? n 0)
        (if (integer? n)
          (power x n)
          (to-math-expr <Apply "**" (map from-math-expr {x n})>))
        (/ 1 (** x (neg n))))
      (to-math-expr <Apply "**" (map from-math-expr {x n})>))))

(define $**'
  (lambda [$x $n]
    (if (rational? n)
      (if (gte? n 0)
        (if (integer? n)
          (power' x n)
          (to-math-expr' <Apply "**" (map from-math-expr {x n})>))
        (/' 1 (**' x (neg n))))
      (to-math-expr' <Apply "**" (map from-math-expr {x n})>))))

(define $rt
  (lambda [$n $x]
    (if (rational? x)
      (letrec {[$f (lambda [$xs]
                     (match xs (assoc-multiset integer)
                       {[<nil> [1 1]]
                        [<ncons $k $p $rs>
                         (let {[$ret (f rs)]}
                           [(*' (**' p (quotient k n)) (2#%1 ret)) (*' (**' p (remainder k n)) (2#%2 ret))])]}))]}
        (letrec {[$g (lambda [$x]
                       (match (f (to-assoc (p-f x))) [integer integer]
                         {[[$x ,1] x]
                          [[$y $z] (*' y (rt' n z))]}))]}
          (if (gt? x 0)
            (/' (g (numerator x)) (g (denominator x)))
            (*' (/' (g (numerator (abs x))) (g (denominator x))) i))))
      (rt' n x))))

(define $rt'
  (lambda [$n $x]
    (if (and (integer? n) (integer? x))
      (match [n x] [integer integer]
        {[[,2 _] (sqrt' x)]
         [[_ _] (to-math-expr' <Apply "rt" (map from-math-expr {n x})>)]})
      (to-math-expr' <Apply "rt" (map from-math-expr {n x})>))))

(define $sqrt
  (lambda [$x]
    (if (rational? x)
      (rt 2 x)
      (sqrt' x))))

(define $rt-of-unity rtu)

(define $rtu
  (lambda [$n]
    (rtu' n)))

(define $rtu'
  (lambda [$n]
    (if (integer? n)
      (match n integer
        {[,1 1]
         [,2 -1]
         [,3 w]
         [,4 i]
         [_ (to-math-expr' <Apply "rtu" (map from-math-expr {n})>)]
         })
      (to-math-expr' <Apply "rtu" (map from-math-expr {n})>))))


