;;;;;
;;;;;
;;;;; Term Rewriting
;;;;;
;;;;;

(define $term-rewriting-rules {[(*' i i) -1] [(*' w w w) 1] [(*' w w) (+' (*' -1 w) -1)]})

(define $rewrite-math-expr-with-rules
  (lambda [$mexpr $rules]
    (if (number? mexpr)
      (if (rational? mexpr)
        mexpr
        (match rules (list [something something])
          {[<nil> mexpr]
           [<cons [$sym $mexpr2] $rests>
            (rewrite-math-expr-with-rules (rewrite-math-expr-with-a-rule mexpr sym mexpr2)
                                          rests)]}))
      mexpr)))

(define $rewrite-math-expr-with-a-rule
  (lambda [$mexpr $sym $mexpr2]
    (match mexpr math-expr
      {[<div $pexpr1 $pexpr2>
        (/' (rewrite-poly-expr-with-a-rule pexpr1 sym mexpr2)
           (rewrite-poly-expr-with-a-rule pexpr2 sym mexpr2))]})))

(define $rewrite-poly-expr-with-a-rule
  (lambda [$pexpr $sym $mexpr]
    (match pexpr poly-expr
      {[<plus $ts>
        (let {[$ret (map (rewrite-term-with-a-rule $ sym mexpr) ts)]}
          (foldl +' 0 ret))]})))

(define $rewrite-term-with-a-rule
  (lambda [$term $sym $mexpr]
    (match [sym term] [symbol-expr term-expr]
      {
       [[<symbol $v $n> <term $a <cons <symbol ,v (& ?(gte? $ n) $k)> $xs>>]
        (rewrite-math-expr-with-a-rule (*' (foldl *' (to-math-expr' <Term a {<Symbol v (modulo k n)>}>) xs)
                                          (foldl *' 1 (take (quotient k n) (repeat1 mexpr))))
                                       sym mexpr)]
       [[_ $t]
        t]})))
