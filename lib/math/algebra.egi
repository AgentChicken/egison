;;;;;
;;;;;
;;;;; Algebra
;;;;;
;;;;;

;;;
;;; Root
;;;

(define $rt
  (lambda [$n $x]
    (if (integer? n)
      (match x math-expr
        {[,0 0]
         [?monomial? (rt' n x)]
         [<div <plus $xs> <plus $ys>>
          (let {[$xd (reduce gcd xs)]
                [$yd (reduce gcd ys)]}
            (let {[[$a $r] (from-monomial (rt' n (/ xd yd)))]}
              (*' a
                 (rt'' n (*' (** r 2) (/' (sum' (map (/' $ xd) xs)) (sum' (map (/' $ yd) ys)))))
                 )))]})
      (rt'' n x))))

(define $rt'
  (lambda [$n $x]
    (letrec {[$f (lambda [$xs]
                   (match xs (assoc-multiset integer)
                     {[<nil> [1 1]]
                      [<ncons $k $p $rs>
                       (let {[$ret (f rs)]}
                         [(*' (**' p (quotient k n)) (2#%1 ret)) (*' (**' p (remainder k n)) (2#%2 ret))])]}))]}
      (letrec {[$g (lambda [$x]
                     (match x term-expr
                       {[<term $a $xs>
                         (match (f {@(to-assoc (p-f (abs a))) @xs}) [math-expr math-expr]
                           {[[$x ,1] (if (lt? a 0) (*' i x) x)]
                            [[$y $z] (if (lt? a 0) (*' i y (rt'' n z)) (*' y (rt'' n z)))]})]}))]}
        (/' (g (numerator x)) (g (denominator x)))))))

(define $rt''
  (lambda [$n $x]
    (match [n x] [integer integer]
      {[[,2 _] (to-math-expr' <Apply sqrt (map from-math-expr {x})>)]
       [[_ _] (to-math-expr' <Apply rt (map from-math-expr {n x})>)]})))

(define $sqrt
  (lambda [$x]
    (if (number? x)
      (let {[$m (numerator x)]
            [$n (denominator x)]}
        (/ (rt 2 (* m n)) n))
      (b.sqrt x))))

(define $rt-of-unity rtu)

(define $rtu
  (lambda [$n]
    (rtu' n)))

(define $rtu'
  (lambda [$n]
    (if (integer? n)
      (match n integer
        {[,1 1]
         [,2 -1]
         [,3 w]
         [,4 i]
         [_ (to-math-expr' <Apply rtu (map from-math-expr {n})>)]
         })
      (to-math-expr' <Apply rtu (map from-math-expr {n})>))))

;;;
;;; Inverse
;;;

(define $inverse
  (lambda [$t $x $f]
    (match f math-expr
      {[?simple-term?
        (match f symbol-expr
          {[,x t]
           [(exp ,x) (log t)]
           [(log ,x) (exp t)]
           [(sqrt ,x) (** t 2)]
           [(cos ,x) (acos t)]
           [(sin ,x) (asin t)]
           [(acos ,x) (cos t)]
           [(asin ,x) (sin t)]
           [_ (inverse' t x f)]
           })]
       [?term?
        (match f term-expr
          {[<term ,1 <ncons $n ,x <nil>>> (rt n t)]
           [<term ,1 <ncons $n $fx <nil>>>
            (inverse' t x fx)
            ]
           [<term $a $fxs> (inverse (/ t a) x (foldl *' 1 (map 2#(**' %1 %2) fxs)))]
           })]
       [_ (inverse'' t x f)]})))

(define $inverse'
  (lambda [$t $x $f]
    (to-math-expr <Apply inverse (map from-math-expr {t x f})>)))

(define $solve1
  (lambda [$f $expr $x]
    (match f math-expr
      {[?simple-term?
        (match f symbol-expr
          {[,x expr]
           [_ (solve1' f expr x)]})]
       [?term?
        (match f term-expr
          {[<term $a $syms>
            (let {[[$xs $cs] (partition 2#(contain-symbol? x %1) syms)]}
              (solve1 (foldl *' 1 (map 2#(**' %1 %2) xs))
                      (/ expr (* a (foldl *' 1 (map 2#(**' %1 %2) cs))))
                      x))]
           [_ (solve1' f expr x)]})]
       [?polynomial?
        (match f poly-expr
          {[<plus $ts>
            (let* {[[$fxs $cs] (partition (contain-term? x $) ts)]
                   [$a (coefficient x (sum fxs))]}
              (solve1 x (/ (- expr (sum cs)) a) x))]})]
       [_
        (match f math-expr
          {[<div $p1 $p2>
            (solve1 p1 (* p2 expr) x)]})]
       })))

(define $solve1'
  (lambda [$f $expr $x]
    (to-math-expr <Apply solve1 (map from-math-expr {f expr x})>)))

(define $solve
  (cambda $eqs
    (solve' eqs {})))

(define $solve'
  (lambda [$eqs $rets]
    (match eqs (list [math-expr math-expr symbol-expr])
      {[<nil> rets]
       [<cons [$f $expr $x] $rs>
        (solve' rs {@rets [x (solve1 (substitute rets f) (substitute rets expr) x)]})]})))

;;;
;;; Quadratic Equations
;;;
(define $quadratic-formula q-f)

(define $q-f
  (lambda [$a $b $c]
    [(/ (+ (* -1 b) (sqrt (- (** b 2) (* 4 a c)))) (* 2 a))
     (/ (- (* -1 b) (sqrt (- (** b 2) (* 4 a c)))) (* 2 a))]))
