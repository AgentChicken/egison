;;;;;
;;;;;
;;;;; Differentiation
;;;;;
;;;;;

(define $∂/∂
  (lambda [%f %x]
    (match f math-expr
      {; symbol
       [,x 1]
       [<symbol _ _> 0]
       ; function application
       [<apply (& ?scalar? $g) (& $args <join $hs <cons ,x _>>)>
        (capply '(add-subscript g (+ (length hs) 1)) args)]
       [<apply (& ?scalar? $g) $args>
        (sum (map (lambda [$t] (* (∂/∂ (capply g args) t) (∂/∂ t x)))
                  args))]
       [<apply _ _> (d/d f x)]
       ; term (constant)
       [,0 0]
       [<term _ <nil>> 0]
       ; term (multiplication)
       [<term ,1 <ncons $n $fx <nil>>> (* n (** fx (- n 1)) (∂/∂ fx x))]
       [<mult $a <ncons $n $fx $r>>
        (+ (* a (∂/∂ (**' fx n) x) r)
           (* a (**' fx n) (∂/∂ r x)))]
       ; polynomial
       [<poly $ts> (sum (map (∂/∂ $ x) ts))]
       ; quotient
       [<div $p1 $p2>
        (let {[$p1' (∂/∂ p1 x)]
              [$p2' (∂/∂ p2 x)]}
          (/ (- (* p1' p2) (* p2' p1)) (** p2 2)))]
       })))

(define $d/d
  (lambda [$f $x]
    (match f math-expr
      {; function application
       [(,exp $g) (* (exp g) (∂/∂ g x))]
       [(,** $g $h) (* f (∂/∂ (* (log g) h) x))]
       [(,log $g) (* (/ 1 g) (∂/∂ g x))]
       [(,cos $g) (* (* -1 (sin g)) (∂/∂ g x))]
       [(,sin $g) (* (cos g) (∂/∂ g x))]
       [(,sqrt $g) (* (/ 1 (* 2 (sqrt g))) (∂/∂ g x))]
       [_ (∂/∂ f x)]
       })))

(define $pd/pd ∂/∂)

(define $taylor-expansion
  (lambda [$f $x $a]
    (map2 *
          (map 1#(/ (** (- x a) %1) (fact %1)) nats0)
          (map (substitute {[x a]} $) (iterate (∂/∂ $ x) f)))))

(define $maclaurin-expansion (taylor-expansion $ $ 0))

(define $∇ ∂/∂)
(define $nabla ∇)

(define $div (compose ∇ (trace $)))

(define $multivariate-taylor-expansion
  (lambda [$f $xs $as]
    (with-symbols {h}
      (let {[$hs (generate-tensor 1#h_%1 (tensor-size xs))]}
        (map2 *
              (map 1#(/ 1 (fact %1)) nats0)
              (map (compose (new-substitute xs as $)
                            (new-substitute hs (- xs as) $))
                   (iterate (compose (∇ $ xs) (V.* hs $)) f)))))))

(define $new-substitute
  (lambda [$xs $ys $mexpr]
    (substitute (zip (tensor-to-list xs) (tensor-to-list ys)) mexpr)))

;(define $multivariate-taylor-expansion
;  (lambda [$f $xs $as]
;    (with-symbols {h}
;      (let* {[$n (length xs)]
;             [$hs (map 1#h_%1 (between 1 n))]
;             [$hv (tensor {n} hs)]
;             [$xas (map2 - xs as)]}
;        (map2 *
;              (map 1#(/ 1 (fact %1)) nats0)
;              (map (compose (substitute (zip xs as) $)
;                            (substitute (zip hs xas) $))
;                   (iterate (compose (∇ $ xs) (V.* hv $)) f)))))))

(define $multivariate-maclaurin-expansion
  (lambda [$f $xs]
    (multivariate-taylor-expansion f xs (generate-tensor 1#0 (tensor-size xs)))))
