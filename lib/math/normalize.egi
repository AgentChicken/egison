;;;;;
;;;;;
;;;;; Term Rewriting
;;;;;
;;;;;

(define $math-normalize
  (lambda [$fn $x1 $x2]
    ((capply compose (map 3#%1 (filter 3#(or (%2 x1) (%3 x2)) rewrite-rules))) (fn x1 x2))))

(define $rewrite-rules
  {
   [id 1##t 1##t]
;   [rewrite-rule-for-i 1##f (contain-symbol? i $)]
;   [rewrite-rule-for-w 1##f (contain-symbol? w $)]
   [rewrite-rule-for-rtu 1##f 1#(or (contain-symbol? i %1) (contain-symbol? w %1) (contain-function? rtu %1))]
;   [rewrite-rule-for-sqrt 1##f (contain-function? sqrt $)]
   [rewrite-rule-for-rt 1##f 1#(or (contain-function? sqrt %1) (contain-function? rt %1))]
   [rewrite-rule-for-cos-and-sin 1#(or (contain-function? cos %1) (contain-function? sin %1)) 1#(or (contain-function? cos %1) (contain-function? sin %1))]
   })

;;
;; i
;;

(define $rewrite-rule-for-i (map-terms rewrite-rule-for-i-term $))

(define $rewrite-rule-for-i-term
  (lambda [$term]
    (match term math-expr
      {[(* $a ,i^(& ?even? $k) $r)
        (*' a (**' -1 (quotient k 2)) r)]
       [(* $a ,i^$k $r)
        (*' a (**' -1 (quotient k 2)) r i)]
       [_ term]})))

;;
;; w
;;

(define $rewrite-rule-for-w
  (compose (map-terms rewrite-rule-for-w-term $)
           (map-polys rewrite-rule-for-w-poly $)))

(define $rewrite-rule-for-w-term
  (lambda [$term]
    (match term math-expr
      {[(* $a ,w^(& ?(gte? $ 3) $k) $r)
        (*' a r (**' w (remainder k 3)))]
       [_ term]})))

(define $rewrite-rule-for-w-poly
  (lambda [$poly]
    (match poly math-expr
      {[(+ (* $a ,w^,2 $mr)
           (* $b ,w ,mr)
           $pr)
        (rewrite-rule-for-w-poly (+' pr
                                    (*' -1 a mr)
                                    (*' (- b a) mr w)
                                    ))]
       [_ poly]})))

;;
;; rtu (include i and w)
;;

(define $rewrite-rule-for-rtu
  (compose (map-terms rewrite-rule-for-i-term $)
           (map-terms rewrite-rule-for-w-term $)
           (map-terms rewrite-rule-for-rtu-term $)
           (map-polys rewrite-rule-for-w-poly $)
           (map-polys rewrite-rule-for-rtu-poly $)
           ))

(define $rewrite-rule-for-rtu-term
  (lambda [$term]
    (match term math-expr
      {[(* $a (,rtu (& ?(gte? k $) $n))^$k $r)
        (*' a (**' (rtu n) (remainder k n)) r)]
       [_ term]})))

(define $rewrite-rule-for-rtu-poly
  (lambda [$poly]
    (match poly math-expr
      {[(+ (* $a (,rtu (& ,(+ k 1) $n))^$k $mr)
           (loop $i [2 ,(- n 1)]
             (+ (* ,a ,(rtu n)^,(- n i) ,mr) ...)
             $pr))
        (rewrite-rule-for-rtu-poly (+' pr (*' -1 a mr)))]
       [_ poly]})))

;;
;; sqrt
;;

(define $rewrite-rule-for-sqrt (map-terms rewrite-rule-for-sqrt-term $))

(define $rewrite-rule-for-sqrt-term
  (lambda [$term]
    (match term math-expr
      {[(* $a (,sqrt $x) (,sqrt ,x) $r)
        (rewrite-rule-for-sqrt-term (*' a x r))]
       [(* $a (,sqrt (& ?term? $x)) (,sqrt (& ?term? $y)) $r)
        (let* {[$d (gcd x y)]
               [[$a1 $x1] (from-monomial (/ x d))]
               [[$a2 $y1] (from-monomial (/ y d))]}
          (*' a d
             (sqrt (*' a1 a2)) (sqrt x1) (sqrt y1)
             r))]
       [_ term]})))

;;
;; rt (include sqrt)
;;

(define $rewrite-rule-for-rt
  (compose (map-terms rewrite-rule-for-sqrt-term $)
           (map-terms rewrite-rule-for-rt-term $)))

(define $rewrite-rule-for-rt-term
  (lambda [$term]
    (match term math-expr
      {[(* $a (,rt (& ?(gte? k $) $n) $x)^$k $r)
        (*' a (**' x (quotient k n)) (**' (rt n x) (remainder k n)) r)]
       [_ term]})))

;;
;; cos, sin
;;

(define $rewrite-rule-for-cos-and-sin (map-polys rewrite-rule-for-cos-and-sin-poly $))

(define $rewrite-rule-for-cos-and-sin-poly
  (lambda [$poly]
    (match poly math-expr
      {[(+ (* $a (,cos $θ)^,2 $mr)
           (* ,a (,sin ,θ)^,2 ,mr)
           $pr)
        (rewrite-rule-for-cos-and-sin-poly (+' pr (*' a mr)))]
       [(+ (* $a $mr)
           (* ,(*' -1 a) (,sin $θ)^,2 ,mr)
           $pr)
        (rewrite-rule-for-cos-and-sin-poly (+' (*' a (cos θ)^2 mr)))]
       [(+ (* $a $mr)
           (* ,(*' -1 a) (,cos $θ)^,2 ,mr)
           $pr)
        (rewrite-rule-for-cos-and-sin-poly (+' (*' a (sin θ)^2)))]
       [_ poly]})))

;;
;; d
;;

(define $rewrite-rule-for-d (map-terms rewrite-rule-for-d-term $))

(define $rewrite-rule-for-d-term
  (lambda [$term]
    (match term math-expr
      {[(* _ (,d _) (,d _) _)
        0]
       [_ term]})))