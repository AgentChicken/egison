;;;;;
;;;;;
;;;;; Mathematical Analysis
;;;;;
;;;;;

(define $d/d
  (lambda [$f $x]
    (match f math-expr
      {[?simple-term?
        (match [x f] [symbol-expr symbol-expr]
          {[[<symbol $name> <symbol !,name>] 0]
           [[<symbol $name> <symbol ,name>] 1]
           [[_ (exp $y)] (* (exp y) (d/d y x))]
           [[_ (** $a $y)] (* (** a y) (log a) (d/d y x))]
           [[_ (log $y)] (* (/ 1 y) (d/d y x))]
           [[_ (cos $y)] (* (sin y) (d/d y x))]
           [[_ (sin $y)] (* -1 (cos y) (d/d y x))]
           [[_ (sqrt $y)] (* (/ 1 (* 2 (sqrt y))) (d/d y x))]
           })]
       [?term?
        (match [x f] [symbol-expr term-expr]
          {[[_ <term _ <nil>>]
            0]
           [[_ <term ,1 <ncons $n $s <nil>>>]
            (* n (** s (- n 1)) (d/d s x))]
           [[_ <term $a <cons $fx $ts>>]
            (+ (* (d/d fx x)
                  a (foldl *' 1 (map 2#(**' %1 %2) ts)))
               (* fx
                  (d/d (*  a (foldl *' 1 (map 2#(**' %1 %2) ts))) x)))]
           })]
       [?polynomial?
        (match [x f] [symbol-expr poly-expr]
          {[[_ <plus $ts>]
            (sum (map (d/d $ x) ts))]
           })]
       [_ 
        (match [x f] [symbol-expr math-expr]
          {[[_ <div $p1 $p2>]
            (let {[$p1' (d/d p1 x)]
                  [$p2' (d/d p2 x)]}
              (/ (- (* p1' p2) (* p2' p1)) (** p2 2)))]
           })]
       })))

(define $d/dx (d/d $ x)) ; just a syntax sugar
(define $d/dy (d/d $ y)) ; just a syntax sugar
(define $d/dz (d/d $ z)) ; just a syntax sugar

(define $Sd
  (lambda [$x $f]
    (match f math-expr
      {[?simple-term?
        (match [x f] [symbol-expr symbol-expr]
          {[[<symbol $name> <symbol !,name>] (* f x)]
           [[<symbol $name> <symbol ,name>] (* (/ 1 2) x^2)]
           [[_ <apply ,"exp" <cons ,x <nil>>>] f]
           [[_ <apply ,"cos" <cons ,x <nil>>>] (sin x)]
           [[_ <apply ,"sin" <cons ,x <nil>>>] (* -1 (cos x))]
           [[_ _] (Sd' x f)]
           })]
       [_ (Sd' x f)]})))

(define $Sd'
  (lambda [$x $f]
    (to-math-expr <Apply "Sd" (map from-math-expr {x f})>)))
